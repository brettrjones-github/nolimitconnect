

/*
 *      Copyright (C) 2005-2013 Team XBMC
 *      http://xbmc.org
 *
 *  This Program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  This Program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with XBMC; see the file COPYING.  If not, write to
 *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *  http://www.gnu.org/copyleft/gpl.html
 *
 */

// ************************************************************************
// This file was generated by xbmc compile process. DO NOT EDIT!!
//  It was created by running the code generator on the spec file for
//  the module "xbmcdrm" on the template file PythonSwig.template.cpp
// ************************************************************************



#include <Python.h>
#include <string>
#include "interfaces/python/LanguageHook.h"
#include "interfaces/python/swig.h"
#include "interfaces/python/PyContext.h"


#if defined(TARGET_WINDOWS)
#  include <windows.h>
#endif

#include "interfaces/legacy/DrmCryptoSession.h"
#include "utils/log.h"

using namespace XBMCAddon;
using namespace xbmcdrm;

#if defined(__GNUG__)
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif



namespace PythonBindings
{

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmcdrm::CryptoSession
  TypeInfo TyXBMCAddon_xbmcdrm_CryptoSession_Type(typeid(XBMCAddon::xbmcdrm::CryptoSession));
  //=========================================================================



  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "UUID",
          "cipherAlgorithm",
          "macAlgorithm",
          NULL};
         
    std::string  UUID ;
    PyObject* pyUUID = NULL;         
    std::string  cipherAlgorithm ;
    PyObject* pycipherAlgorithm = NULL;         
    std::string  macAlgorithm ;
    PyObject* pymacAlgorithm = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"OOO",
       (char**)keywords,
         &pyUUID,
         &pycipherAlgorithm,
         &pymacAlgorithm
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmcdrm::CryptoSession * apiResult;
    try
    {
      if (pyUUID) PyXBMCGetUnicodeString(UUID,pyUUID,false,"UUID","CryptoSession"); 
      if (pycipherAlgorithm) PyXBMCGetUnicodeString(cipherAlgorithm,pycipherAlgorithm,false,"cipherAlgorithm","CryptoSession"); 
      if (pymacAlgorithm) PyXBMCGetUnicodeString(macAlgorithm,pymacAlgorithm,false,"macAlgorithm","CryptoSession"); 

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = (XBMCAddon::xbmcdrm::CryptoSession *)new XBMCAddon::xbmcdrm::CryptoSession(  UUID,  cipherAlgorithm,  macAlgorithm  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmcdrm::CryptoSession\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmcdrm::CryptoSession\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_GetKeyRequest (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "init",
          "mimeType",
          "offlineKey",
          "optionalParameters",
          NULL};
         
    XbmcCommons::Buffer  init ;
    PyObject* pyinit = NULL;         
    std::string  mimeType ;
    PyObject* pymimeType = NULL;         
    bool  offlineKey ;         
    std::map< XBMCAddon::String ,XBMCAddon::String  >  optionalParameters ;
    PyObject* pyoptionalParameters = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"OObO",
       (char**)keywords,
         &pyinit,
         &pymimeType,
         &offlineKey,
         &pyoptionalParameters
       ))
    {
      return NULL;
    }

    XbmcCommons::Buffer  apiResult;
    try
    {
      
    if (PyString_Check(pyinit))
    {
      const char* str = PyString_AsString(pyinit);
      size_t size = (size_t)PyString_Size(pyinit);
      init.allocate(size);
      init.put(str,size);
      init.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyinit))
    {
      size_t size = PyByteArray_Size(pyinit);
      init.allocate(size);
      init.put(PyByteArray_AsString(pyinit),size);
      init.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "init", "GetKeyRequest"); 
      if (pymimeType) PyXBMCGetUnicodeString(mimeType,pymimeType,false,"mimeType","GetKeyRequest"); 
      
    {
      PyObject *pykey, *pyvalue;
      Py_ssize_t pos = 0;
      while(PyDict_Next(pyoptionalParameters, &pos, &pykey, &pyvalue))
      {
        std::string  key;
        std::string  value;
        if (pykey) PyXBMCGetUnicodeString(key,pykey,false,"key","GetKeyRequest");
        if (pyvalue) PyXBMCGetUnicodeString(value,pyvalue,false,"value","GetKeyRequest");
        optionalParameters[key] = value;
      }
    } 

      apiResult = (XbmcCommons::Buffer )((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"GetKeyRequest","XBMCAddon::xbmcdrm::CryptoSession"))-> GetKeyRequest(  init,  mimeType,  offlineKey,  optionalParameters  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"GetKeyRequest\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"GetKeyRequest\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyByteArray_FromStringAndSize((char*)apiResult.curPosition(),apiResult.remaining());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_GetPropertyString (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "name",
          NULL};
         
    std::string  name ;
    PyObject* pyname = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"O",
       (char**)keywords,
         &pyname
       ))
    {
      return NULL;
    }

    std::string  apiResult;
    try
    {
      if (pyname) PyXBMCGetUnicodeString(name,pyname,false,"name","GetPropertyString"); 

      apiResult = (std::string )((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"GetPropertyString","XBMCAddon::xbmcdrm::CryptoSession"))-> GetPropertyString(  name  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"GetPropertyString\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"GetPropertyString\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyString_FromStringAndSize(apiResult.c_str(), apiResult.length());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_ProvideKeyResponse (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "response",
          NULL};
         
    XbmcCommons::Buffer  response ;
    PyObject* pyresponse = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"O",
       (char**)keywords,
         &pyresponse
       ))
    {
      return NULL;
    }

    std::string  apiResult;
    try
    {
      
    if (PyString_Check(pyresponse))
    {
      const char* str = PyString_AsString(pyresponse);
      size_t size = (size_t)PyString_Size(pyresponse);
      response.allocate(size);
      response.put(str,size);
      response.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyresponse))
    {
      size_t size = PyByteArray_Size(pyresponse);
      response.allocate(size);
      response.put(PyByteArray_AsString(pyresponse),size);
      response.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "response", "ProvideKeyResponse"); 

      apiResult = (std::string )((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"ProvideKeyResponse","XBMCAddon::xbmcdrm::CryptoSession"))-> ProvideKeyResponse(  response  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"ProvideKeyResponse\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"ProvideKeyResponse\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyString_FromStringAndSize(apiResult.c_str(), apiResult.length());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_RemoveKeys (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"RemoveKeys","XBMCAddon::xbmcdrm::CryptoSession"))-> RemoveKeys(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"RemoveKeys\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"RemoveKeys\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_RestoreKeys (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "keySetId",
          NULL};
         
    std::string  keySetId ;
    PyObject* pykeySetId = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"O",
       (char**)keywords,
         &pykeySetId
       ))
    {
      return NULL;
    }


    try
    {
      if (pykeySetId) PyXBMCGetUnicodeString(keySetId,pykeySetId,false,"keySetId","RestoreKeys"); 

      ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"RestoreKeys","XBMCAddon::xbmcdrm::CryptoSession"))-> RestoreKeys(  keySetId  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"RestoreKeys\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"RestoreKeys\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_SetPropertyString (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "name",
          "value",
          NULL};
         
    std::string  name ;
    PyObject* pyname = NULL;         
    std::string  value ;
    PyObject* pyvalue = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"OO",
       (char**)keywords,
         &pyname,
         &pyvalue
       ))
    {
      return NULL;
    }


    try
    {
      if (pyname) PyXBMCGetUnicodeString(name,pyname,false,"name","SetPropertyString"); 
      if (pyvalue) PyXBMCGetUnicodeString(value,pyvalue,false,"value","SetPropertyString"); 

      ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"SetPropertyString","XBMCAddon::xbmcdrm::CryptoSession"))-> SetPropertyString(  name,  value  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"SetPropertyString\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"SetPropertyString\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Decrypt (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "cipherKeyId",
          "input",
          "iv",
          NULL};
         
    XbmcCommons::Buffer  cipherKeyId ;
    PyObject* pycipherKeyId = NULL;         
    XbmcCommons::Buffer  input ;
    PyObject* pyinput = NULL;         
    XbmcCommons::Buffer  iv ;
    PyObject* pyiv = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"OOO",
       (char**)keywords,
         &pycipherKeyId,
         &pyinput,
         &pyiv
       ))
    {
      return NULL;
    }

    XbmcCommons::Buffer  apiResult;
    try
    {
      
    if (PyString_Check(pycipherKeyId))
    {
      const char* str = PyString_AsString(pycipherKeyId);
      size_t size = (size_t)PyString_Size(pycipherKeyId);
      cipherKeyId.allocate(size);
      cipherKeyId.put(str,size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pycipherKeyId))
    {
      size_t size = PyByteArray_Size(pycipherKeyId);
      cipherKeyId.allocate(size);
      cipherKeyId.put(PyByteArray_AsString(pycipherKeyId),size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "cipherKeyId", "Decrypt"); 
      
    if (PyString_Check(pyinput))
    {
      const char* str = PyString_AsString(pyinput);
      size_t size = (size_t)PyString_Size(pyinput);
      input.allocate(size);
      input.put(str,size);
      input.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyinput))
    {
      size_t size = PyByteArray_Size(pyinput);
      input.allocate(size);
      input.put(PyByteArray_AsString(pyinput),size);
      input.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "input", "Decrypt"); 
      
    if (PyString_Check(pyiv))
    {
      const char* str = PyString_AsString(pyiv);
      size_t size = (size_t)PyString_Size(pyiv);
      iv.allocate(size);
      iv.put(str,size);
      iv.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyiv))
    {
      size_t size = PyByteArray_Size(pyiv);
      iv.allocate(size);
      iv.put(PyByteArray_AsString(pyiv),size);
      iv.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "iv", "Decrypt"); 

      apiResult = (XbmcCommons::Buffer )((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"Decrypt","XBMCAddon::xbmcdrm::CryptoSession"))-> Decrypt(  cipherKeyId,  input,  iv  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"Decrypt\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"Decrypt\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyByteArray_FromStringAndSize((char*)apiResult.curPosition(),apiResult.remaining());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Encrypt (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "cipherKeyId",
          "input",
          "iv",
          NULL};
         
    XbmcCommons::Buffer  cipherKeyId ;
    PyObject* pycipherKeyId = NULL;         
    XbmcCommons::Buffer  input ;
    PyObject* pyinput = NULL;         
    XbmcCommons::Buffer  iv ;
    PyObject* pyiv = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"OOO",
       (char**)keywords,
         &pycipherKeyId,
         &pyinput,
         &pyiv
       ))
    {
      return NULL;
    }

    XbmcCommons::Buffer  apiResult;
    try
    {
      
    if (PyString_Check(pycipherKeyId))
    {
      const char* str = PyString_AsString(pycipherKeyId);
      size_t size = (size_t)PyString_Size(pycipherKeyId);
      cipherKeyId.allocate(size);
      cipherKeyId.put(str,size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pycipherKeyId))
    {
      size_t size = PyByteArray_Size(pycipherKeyId);
      cipherKeyId.allocate(size);
      cipherKeyId.put(PyByteArray_AsString(pycipherKeyId),size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "cipherKeyId", "Encrypt"); 
      
    if (PyString_Check(pyinput))
    {
      const char* str = PyString_AsString(pyinput);
      size_t size = (size_t)PyString_Size(pyinput);
      input.allocate(size);
      input.put(str,size);
      input.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyinput))
    {
      size_t size = PyByteArray_Size(pyinput);
      input.allocate(size);
      input.put(PyByteArray_AsString(pyinput),size);
      input.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "input", "Encrypt"); 
      
    if (PyString_Check(pyiv))
    {
      const char* str = PyString_AsString(pyiv);
      size_t size = (size_t)PyString_Size(pyiv);
      iv.allocate(size);
      iv.put(str,size);
      iv.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyiv))
    {
      size_t size = PyByteArray_Size(pyiv);
      iv.allocate(size);
      iv.put(PyByteArray_AsString(pyiv),size);
      iv.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "iv", "Encrypt"); 

      apiResult = (XbmcCommons::Buffer )((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"Encrypt","XBMCAddon::xbmcdrm::CryptoSession"))-> Encrypt(  cipherKeyId,  input,  iv  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"Encrypt\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"Encrypt\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyByteArray_FromStringAndSize((char*)apiResult.curPosition(),apiResult.remaining());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Sign (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "macKeyId",
          "message",
          NULL};
         
    XbmcCommons::Buffer  macKeyId ;
    PyObject* pymacKeyId = NULL;         
    XbmcCommons::Buffer  message ;
    PyObject* pymessage = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"OO",
       (char**)keywords,
         &pymacKeyId,
         &pymessage
       ))
    {
      return NULL;
    }

    XbmcCommons::Buffer  apiResult;
    try
    {
      
    if (PyString_Check(pymacKeyId))
    {
      const char* str = PyString_AsString(pymacKeyId);
      size_t size = (size_t)PyString_Size(pymacKeyId);
      macKeyId.allocate(size);
      macKeyId.put(str,size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pymacKeyId))
    {
      size_t size = PyByteArray_Size(pymacKeyId);
      macKeyId.allocate(size);
      macKeyId.put(PyByteArray_AsString(pymacKeyId),size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "macKeyId", "Sign"); 
      
    if (PyString_Check(pymessage))
    {
      const char* str = PyString_AsString(pymessage);
      size_t size = (size_t)PyString_Size(pymessage);
      message.allocate(size);
      message.put(str,size);
      message.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pymessage))
    {
      size_t size = PyByteArray_Size(pymessage);
      message.allocate(size);
      message.put(PyByteArray_AsString(pymessage),size);
      message.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "message", "Sign"); 

      apiResult = (XbmcCommons::Buffer )((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"Sign","XBMCAddon::xbmcdrm::CryptoSession"))-> Sign(  macKeyId,  message  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"Sign\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"Sign\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyByteArray_FromStringAndSize((char*)apiResult.curPosition(),apiResult.remaining());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Verify (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "macKeyId",
          "message",
          "signature",
          NULL};
         
    XbmcCommons::Buffer  macKeyId ;
    PyObject* pymacKeyId = NULL;         
    XbmcCommons::Buffer  message ;
    PyObject* pymessage = NULL;         
    XbmcCommons::Buffer  signature ;
    PyObject* pysignature = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"OOO",
       (char**)keywords,
         &pymacKeyId,
         &pymessage,
         &pysignature
       ))
    {
      return NULL;
    }

    bool  apiResult;
    try
    {
      
    if (PyString_Check(pymacKeyId))
    {
      const char* str = PyString_AsString(pymacKeyId);
      size_t size = (size_t)PyString_Size(pymacKeyId);
      macKeyId.allocate(size);
      macKeyId.put(str,size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pymacKeyId))
    {
      size_t size = PyByteArray_Size(pymacKeyId);
      macKeyId.allocate(size);
      macKeyId.put(PyByteArray_AsString(pymacKeyId),size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "macKeyId", "Verify"); 
      
    if (PyString_Check(pymessage))
    {
      const char* str = PyString_AsString(pymessage);
      size_t size = (size_t)PyString_Size(pymessage);
      message.allocate(size);
      message.put(str,size);
      message.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pymessage))
    {
      size_t size = PyByteArray_Size(pymessage);
      message.allocate(size);
      message.put(PyByteArray_AsString(pymessage),size);
      message.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "message", "Verify"); 
      
    if (PyString_Check(pysignature))
    {
      const char* str = PyString_AsString(pysignature);
      size_t size = (size_t)PyString_Size(pysignature);
      signature.allocate(size);
      signature.put(str,size);
      signature.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pysignature))
    {
      size_t size = PyByteArray_Size(pysignature);
      signature.allocate(size);
      signature.put(PyByteArray_AsString(pysignature),size);
      signature.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "signature", "Verify"); 

      apiResult = (bool )((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"Verify","XBMCAddon::xbmcdrm::CryptoSession"))-> Verify(  macKeyId,  message,  signature  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"Verify\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"Verify\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue((char*)"b", apiResult);

    return result; 
  } 

  static void xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmcdrm::CryptoSession* theObj = (XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"~XBMCAddon::xbmcdrm::CryptoSession","XBMCAddon::xbmcdrm::CryptoSession");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_TypeError, e.GetMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmcdrm::CryptoSession\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmcdrm::CryptoSession\""); 
    }

    self->ob_type->tp_free((PyObject*)self); 
    
  } 
  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmcdrm::CryptoSession
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmcdrm_CryptoSession_methods[] = { 
    {(char*)"GetKeyRequest", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_GetKeyRequest, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {(char*)"GetPropertyString", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_GetPropertyString, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {(char*)"ProvideKeyResponse", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_ProvideKeyResponse, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {(char*)"RemoveKeys", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_RemoveKeys, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {(char*)"RestoreKeys", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_RestoreKeys, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {(char*)"SetPropertyString", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_SetPropertyString, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {(char*)"Decrypt", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Decrypt, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {(char*)"Encrypt", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Encrypt, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {(char*)"Sign", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Sign, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {(char*)"Verify", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Verify, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmcdrm_CryptoSession_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmcdrm_CryptoSession_Type.pythonType;
    pythonType.tp_name = (char*)"xbmcdrm.CryptoSession";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Dealloc; 


    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmcdrm_CryptoSession_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_New;

    TyXBMCAddon_xbmcdrm_CryptoSession_Type.swigType="p.XBMCAddon::xbmcdrm::CryptoSession";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmcdrm_CryptoSession_Type);

  }
  //=========================================================================


  static PyMethodDef xbmcdrm_methods[] = { 
    {NULL, NULL, 0, NULL}
  };

  // This is the call that will call all of the other initializes 
  //  for all of the classes in this module
  static void initTypes()
  {
    static bool typesAlreadyInitialized = false;
    if (!typesAlreadyInitialized)
    {
      typesAlreadyInitialized = true;

      initPyXBMCAddon_xbmcdrm_CryptoSession_Type();
      if (PyType_Ready(&(TyXBMCAddon_xbmcdrm_CryptoSession_Type.pythonType)) < 0)
        return;
    }
  }

  void initModule_xbmcdrm()
  {
    initTypes();

    // init general xbmcdrm modules
    PyObject* module;


    Py_INCREF(&(TyXBMCAddon_xbmcdrm_CryptoSession_Type.pythonType));

    module = Py_InitModule((char*)"xbmcdrm", xbmcdrm_methods);
    if (module == NULL) return;


    PyModule_AddObject(module, (char*)"CryptoSession", (PyObject*)(&(TyXBMCAddon_xbmcdrm_CryptoSession_Type.pythonType)));

   // constants
   PyModule_AddStringConstant(module, (char*)"__author__", (char*)"Team Kodi <http://kodi.tv>");
   PyModule_AddStringConstant(module, (char*)"__date__", (char*)"Thu Jun 21 05:34:06 CDT 2018");
   PyModule_AddStringConstant(module, (char*)"__version__", (char*)"2.25.0");
   PyModule_AddStringConstant(module, (char*)"__credits__", (char*)"Team Kodi");
   PyModule_AddStringConstant(module, (char*)"__platform__", (char*)"ALL");

   // need to handle constants

  }

} // end PythonBindings namespace for python type definitions


