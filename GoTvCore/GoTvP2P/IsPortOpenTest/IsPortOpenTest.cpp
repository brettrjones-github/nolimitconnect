//============================================================================
// Copyright (C) 2014 Brett R. Jones 
// Issued to MIT style license by Brett R. Jones in 2017
//
// You may use, copy, modify, merge, publish, distribute, sub-license, and/or sell this software 
// provided this Copyright is not modified or removed and is included all copies or substantial portions of the Software
//
// This code is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//
// bjones.engineer@gmail.com
// http://www.nolimitconnect.com
//============================================================================

#include "IsPortOpenTest.h"

#include <GoTvCore/GoTvP2P/P2PEngine/P2PEngine.h>
#include <GoTvCore/GoTvP2P/NetServices/NetServiceHdr.h>
#include <GoTvCore/GoTvP2P/NetServices/NetServiceUtils.h>
#include <GoTvCore/GoTvP2P/Network/NetworkStateMachine.h>
#include <GoTvCore/GoTvP2P/Network/NetworkMgr.h>

#include <CoreLib/VxParse.h>
#include <NetLib/VxSktUtil.h>
#include <NetLib/VxPeerMgr.h>
#include <NetLib/VxSktConnectSimple.h>

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _MSC_VER
# pragma warning(disable: 4355) //'this' : used in base member initializer list
#endif //_MSC_VER

namespace
{
	//============================================================================
    void * IsPortOpenTestThreadFunc( void * pvContext )
	{
		VxThread * poThread = (VxThread *)pvContext;
		poThread->setIsThreadRunning( true );
		IsPortOpenTest * anchorTest = (IsPortOpenTest *)poThread->getThreadUserParam();
		if( false == poThread->isAborted() )
		{
			anchorTest->doIsPortOpenTest();
		}
		poThread->threadAboutToExit();
        return nullptr;
	}
}

//============================================================================
IsPortOpenTest::IsPortOpenTest( P2PEngine& engine, EngineSettings& engineSettings, NetServicesMgr& netServicesMgr, NetServiceUtils& netServiceUtils )
: m_Engine( engine )
, m_EngineSettings( engineSettings )
, m_NetServicesMgr( netServicesMgr )
, m_NetServiceUtils( netServiceUtils )
, m_PingResponseServer( *this )
, m_Port( 0 )
{
}

//============================================================================
void IsPortOpenTest::isPortOpenShutdown( void )
{
	stopPingResponse();
	m_IsPortOpenThread.abortThreadRun( true );
}

//============================================================================
void IsPortOpenTest::fromGuiRunIsPortOpenTest( uint16_t port )
{
	m_Port = port;
	stopPingResponse();
	if( ( false == m_Engine.getPeerMgr().isListening() )
		|| ( m_Port != m_Engine.getPeerMgr().getListenPort() ) )
	{
		startPingResponse();
	}

	startIsPortOpenThread();
}

//============================================================================
void IsPortOpenTest::startPingResponse( void )
{
	if( m_PingResponseServer.isListening() )
	{
		m_PingResponseServer.stopListening();
	}

	std::string lclIp = m_Engine.getNetworkStateMachine().getLocalNetworkIp();
	if( lclIp.length() )
	{
		m_PingResponseServer.startListening( lclIp.c_str(), m_Port );
		LogMsg( LOG_INFO, "IsPortOpenTest::startPingResponse: listening ip %s port %d\n", lclIp.c_str(), m_Port );
	}
	else
	{
		m_PingResponseServer.startListening( m_Port );
		LogMsg( LOG_INFO, "IsPortOpenTest::startPingResponse: listening port %d\n", m_Port );
	}
}

//============================================================================
void IsPortOpenTest::stopPingResponse( void )
{
	m_PingResponseServer.stopListening();
}

//============================================================================
void IsPortOpenTest::startIsPortOpenThread( void )
{
	m_IsPortOpenThread.abortThreadRun( true );
	while( m_IsPortOpenThread.isThreadRunning() )
	{
		VxSleep( 200 );
	}

	m_IsPortOpenThread.startThread( (VX_THREAD_FUNCTION_T)IsPortOpenTestThreadFunc, this, "IsPortOpenTestThread" );
}

//============================================================================
void IsPortOpenTest::sendTestStatus( EIsPortOpenStatus eStatus, const char * msg, ... )
{
	char as8Buf[ 1024 ];
	va_list argList;
	va_start( argList, msg );
	vsnprintf( as8Buf, sizeof( as8Buf ), msg, argList );
	as8Buf[sizeof( as8Buf ) - 1] = 0;
	va_end( argList );
	IToGui::getToGui().toGuiIsPortOpenStatus( eStatus, as8Buf );
}

//============================================================================
void IsPortOpenTest::sendTestLog( const char * msg, ... )
{
	char as8Buf[ 1024 ];
	va_list argList;
	va_start( argList, msg );
	vsnprintf( as8Buf, sizeof( as8Buf ), msg, argList );
	as8Buf[sizeof( as8Buf ) - 1] = 0;
	va_end( argList );
	IToGui::getToGui().toGuiIsPortOpenStatus( eIsPortOpenStatusLogMsg, as8Buf );
}

//============================================================================
void IsPortOpenTest::doIsPortOpenTest( void )
{
	std::string nodeUrl;
	m_EngineSettings.getNetServiceWebsiteUrl( nodeUrl );
	if( eIsPortOpenStatusTestComplete != doConnectionTest( nodeUrl, false ) )
	{
		m_EngineSettings.getNetHostWebsiteUrl( nodeUrl );
		if( eIsPortOpenStatusTestComplete != doConnectionTest( nodeUrl, true ) )
		{
			//?
		}
	}
}

//============================================================================
const char * IsPortOpenTest::getTestName( bool isHost )
{
	return "IS PORT OPEN TEST: ";
}

//============================================================================
EIsPortOpenStatus IsPortOpenTest::doConnectionTest( std::string& nodeUrl, bool isHost )
{
	sendTestLog(	"Testing Port using %s node %s Connection Test Service for port %d\n", 
					isHost ? "NET HOST" : "CONNECTION TEST", 
					nodeUrl.c_str(), 
					m_Port );

	VxSktConnectSimple netServConn;
	std::string strHost;
	std::string strFile;
	uint16_t u16Port;
	VxTimer testTimer;
	double connectTime = 0;
	double sendTime= 0;
	double reponseTime= 0;

	LogMsg( LOG_INFO, "IsPortOpenTest: sec %3.3f : connecting to %s\n", testTimer.elapsedSec(), nodeUrl.c_str() );
	if( false == netServConn.connectToWebsite(	nodeUrl.c_str(), 
		strHost, 
		strFile, 
		u16Port, 
		NETSERVICE_CONNECT_TIMEOUT ) )
	{
		sendTestStatus( eIsPortOpenStatusConnectFail, "%s Could not connected to %s..Please check settings\n", getTestName( isHost ), nodeUrl.c_str() );
		if( false == isHost )
		{
			return doConnectTestFailed( isHost );
		}

		return eIsPortOpenStatusConnectFail;
	}

	netServConn.dumpConnectionInfo();
	std::string strNetActionUrl;
	m_NetServiceUtils.buildIsMyPortOpenUrl( &netServConn, strNetActionUrl, m_Port );
	connectTime = testTimer.elapsedSec();
	LogMsg( LOG_INFO, "IsPortOpenTest: sec %3.3f : sending %d action data\n", connectTime, (int)strNetActionUrl.length() );

	RCODE rc = netServConn.sendData( strNetActionUrl.c_str(), strNetActionUrl.length() );
	if( rc )
	{
        if( IsLogEnabled( eLogModuleConnect ) )
		    LogMsg( LOG_ERROR, "NetActionIsMyPortOpen::doAction: sendData error %d\n", rc );
		sendTestStatus( eIsPortOpenStatusConnectionDropped,
			"%s Connected to %s but dropped connection (wrong network name ?) %s\n", getTestName( isHost ), nodeUrl.c_str(), m_Engine.getNetworkMgr().getNetworkKey() );
		return doConnectTestFailed( isHost );
	}

	sendTime = testTimer.elapsedSec();
	LogMsg( LOG_INFO, "IsPortOpenTest: sec %3.3f : waiting for is port open response\n", sendTime );
	char rxBuf[ 512 ];
	NetServiceHdr netServiceHdr;
	if( false == m_NetServiceUtils.rxNetServiceCmd( &netServConn, 
													rxBuf, 
													sizeof( rxBuf ), 
													netServiceHdr, 
													IS_PORT_OPEN_RX_HDR_TIMEOUT, 
													IS_PORT_OPEN_RX_DATA_TIMEOUT ) )
	{
		sendTestStatus( eIsPortOpenStatusConnectionDropped,
			"%s Connected to %s but failed to respond (wrong network name ?)\n", getTestName( isHost ), nodeUrl.c_str() );
		return doConnectTestFailed( isHost );
	}

	std::string content = rxBuf;
	reponseTime = testTimer.elapsedSec();
	LogMsg( LOG_INFO, "IsPortOpenTest: response len %d total time %3.3fsec connect %3.3fsec send %3.3fsec response %3.3fsec : \n", 
		content.length(),
		reponseTime, connectTime, sendTime - connectTime, reponseTime - sendTime );
	if( 0 == content.length() )
	{
        if( IsLogEnabled( eLogModuleConnect ) )
		    LogMsg( LOG_ERROR, "NetActionIsMyPortOpen::doAction: no content in response\n" );
		sendTestStatus( eIsPortOpenStatusInvalidResponse, "%s invalid response content %s\n", getTestName( isHost ), content.c_str() );
		return doConnectTestFailed( isHost );
	}

	const char * contentBuf = content.c_str();
	if( '/' != contentBuf[content.length() -1] )
	{
		LogMsg( LOG_ERROR, "NetActionIsMyPortOpen::doAction: no trailing / in content\n" );
		sendTestStatus( eIsPortOpenStatusInvalidResponse, "%s invalid response content %s\n", getTestName( isHost ), content.c_str() );
		return doConnectTestFailed( isHost );
	}

	((char *)contentBuf)[content.length() -1] = 0;

	std::vector<std::string> contentParts;
	StdStringSplit( content, '-', contentParts );
	if( 2 != contentParts.size() )
	{
		LogMsg( LOG_ERROR, "NetActionIsMyPortOpen::doAction: not enough parts to content\n" );
		sendTestStatus( eIsPortOpenStatusInvalidResponse, "%s invalid response content %s\n", getTestName( isHost ), content.c_str() );
		return doConnectTestFailed( isHost );
	}

	std::string retMyExternalIp = contentParts[1];
	std::string strPayload = contentParts[0];
	int iIsOpen = atoi( contentParts[0].c_str() );

    if( IsLogEnabled( eLogModuleConnect ) )
	    LogMsg( LOG_INFO, "NetActionIsMyPortOpen::doAction: direct connect %s my ip %s result %d\n", strPayload.c_str(), retMyExternalIp.c_str(), iIsOpen );
	if( iIsOpen )
	{
		sendTestStatus( eIsPortOpenStatusOpen, "my ip %s port %d is open\n", retMyExternalIp.c_str(), m_Port );
	}
	else
	{
		sendTestStatus( eIsPortOpenStatusClosed, "my ip %s port %d is NOT open (Relay will be required)\n", retMyExternalIp.c_str(), m_Port );
		if( m_Engine.getNetworkStateMachine().getLocalNetworkIp().length()
			&& m_Engine.getNetworkStateMachine().isCellularNetwork() )
		{
			sendTestLog( "NOTE: Most cell phone providers block all ports and you appear to be on a cellular data network\n");
		}
	}

	sendTestLog( "Elapsed Seconds Connect %3.3fsec Send %3.3fsec Respond %3.3fsec\n", connectTime, sendTime - connectTime, reponseTime - sendTime );
	return doConnectTestSuccess( isHost );
}

//============================================================================
EIsPortOpenStatus IsPortOpenTest::doConnectTestFailed( bool isHost )
{
	sendTestStatus( eIsPortOpenStatusTestComplete,
		"\n" );
	doTestShutdown();
	return eIsPortOpenStatusTestComplete;
}

//============================================================================
EIsPortOpenStatus IsPortOpenTest::doConnectTestSuccess( bool isHost )
{
	sendTestStatus( eIsPortOpenStatusTestComplete,
		"\n" );
	doTestShutdown();
	return eIsPortOpenStatusTestComplete;
}

//============================================================================
void IsPortOpenTest::doTestShutdown( void )
{
	m_PingResponseServer.stopListening();
}

//============================================================================
void IsPortOpenTest::handleTcpData( VxSktBase * sktBase )
{
	if( false == m_NetServiceUtils.verifyAllDataArrivedOfNetServiceUrl( sktBase ) )
	{
		return;
	}

	NetServiceHdr netServiceHdr;
	EPluginType pluginType = m_NetServiceUtils.parseHttpNetServiceUrl( sktBase, netServiceHdr );
	if( ( ePluginTypeNetServices == pluginType )
		&& ( eNetCmdPing == netServiceHdr.m_NetCmdType ) )
	{
		sendTestLog( "got pinged\n");
		std::string content;
		StdStringFormat( content, "PONG-%s", sktBase->getRemoteIp() );
		m_NetServiceUtils.buildAndSendCmd( sktBase, eNetCmdPong, content );
	}
	else
	{
		sendTestLog( "got unknown data from ip %s\n", sktBase->getRemoteIp() );
	}
}


